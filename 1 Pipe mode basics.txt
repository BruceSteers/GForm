
Using pipes and how they work...

What is a pipe?
The best way to think of a pipe is to think of a real pipe that at one end you put in some marbles.
The marbles arrive at the pipes other end in the same order as they went in (first in first out fifo).
Then each marble is removed at the other end one at a time till there are no marbles left.

The same happens with computer files that are pipes but the marbles are lines of text in our case.

Using a pipe file we are able to send lines of text to it from anywhere and have another
program monitoring this file procces the lines in the order that they are sent.

That's how GForm's pipe mode works.

The Outgoing pipe...
Adding the argument 'pipe=/tmp/fifo1' when running GForm in your script will have the app create an
outgoing pipe file that your script can then open and read and wait for any incomming messages that 
GForm will send as the user presses buttons, set's texts, etc.

That's how GForm talks to your script file.
For example...
If you've created a button using 'button=bt1|Hello' when launching GForm then any time the button
is pressed the text 'bt1|Hello' is sent to the pipe file /tmp/fifo1, your script listening 
to this pipe then knows bt1 was pressed and has the text "Hello" 

Simple example. The following runs GForm, opens the pipe with descriptor 3 then 
enters a loop of reading from the file and echo'ing the messages back to cli. 
When GForm closes it will delete the pipe file so the scripts 'while' loop runs until
/tmp/fifo1 has gone.
Note, if there is no text sent then the 'read' command will halt your script until it gets a message.
Note, command to run GForm is finished with '&sleep 1' , this is important to allow your 
script to continue to move on to the the "read" loop. 
The '&' sign makes your script not wait for GForm to close and move on to the next command.
The next command is 'sleep 1' , this just causes the script to pause for a second to give
the GUI time to load and create the pipe file.

---------------------------------
./GForm pipe="/tmp/fifo1" box button="btn|Button 1"  button="BQ|Quit Button|quit" unbox&sleep 1

exec 3</tmp/fifo1 # Open pipe handle
  while [ -e "/tmp/fifo1" ]; do  # enter loop
  read -u 3 PipeText
   if [ ! -z "$PipeText" ]; then  # We got some text so process it.
    echo "message: $PipeText"
   fi
  done
  
exec 3<&- 2>/dev/null  # close opened pipe

--------------------------------

The Listening pipe...
If you add the argument 'listen=/tmp/fifo2' when running GForm it opens a pipe itself for reading.
Adding any text to this file is then read by the GUI and processed.

That's how your script file talks to GForm.
Thare are many GFrom commands to manipulate the main window or objects in the GUI.
See "3 Pipe Command Args.txt" for a full list of commands available.

objects can be hidden, disabled, changed in many ways.
For example...
if you've created a button using 'button=btn1|Hello|disabled' and have used 'listen=/tmp/fifo2' 
then while your GUI is open use the following shell command from your script (or terminal to test)...

echo "enable=btn1" >>/tmp/fifo2

This will then be read by the GForm and cause btn1 to become enabled.
Note. use of the >> sign to 'redirect' the output of the echo command to a file, in our case our 
listening pipe. Use 2 > signs >> as 2 'appends' the message to any existing unread text.

See the example shell scripts and "3 Pipe Command Args.txt" for understanding usage and a full command list.

